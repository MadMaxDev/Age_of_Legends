// Copyright (C) PixelGame, http://www.pixelgame.com
// All rights reserved.
// namespace    : n_whcmn
// File         : wh_crypt_interface.cpp
// Creator      : Wei Hua (魏华)
// Comment      : 通用加密接口默认实现
// CreationDate : 2005-08-17
// Change LOG   : 2006-05-22 修改了IKeyExchanger_X没有使用m_pHost中参数DHSTR参数的问题。所以原来的SetParam是没有用的。
//              : 2006-05-30 吕宝虹增加了基于RSA的KeyExchanger

#include "../inc/wh_crypt_interface.h"
#include "../inc/whstring.h"
#include "../inc/whdes.h"
#include "../inc/whmd5.h"
#include "../inc/whcrc.h"
#include "../inc/whtime.h"
#include "../inc/whbase64.h"
#include <cryptlib/randpool.h>
#include <cryptlib/dh.h>
#include <cryptlib/files.h>
#include <cryptlib/hex.h>
#include <cryptlib/base64.h>
#include <cryptlib/rsa.h>

#include <sstream>
USING_NAMESPACE(CryptoPP)

namespace n_whcmn
{

////////////////////////////////////////////////////////////////////
// 默认的加密工厂
////////////////////////////////////////////////////////////////////
class	ICryptFactory_Dft	: public	ICryptFactory
{
public:
	enum
	{
		XDATASIZE	= 32,
	};
private:
	class	IKeyExchanger_Dft0	: public	ICryptFactory::IKeyExchanger
	{
	public:
		// 自我销毁
		virtual	void	SelfDestroy()
		{
			// 什么也不做
			// 外界调用这个是为了删除自己，但是这个对象是ICryptFactory_Dft的一个成员对象，不用外界删除了
		}
		// 客户端先初始化，得到的数据发送给服务器
		virtual	int		MakeOwnData()
		{
			return		0;
		}
		virtual	int		GetPubSize() const
		{
			return		0;
		}
		virtual	const void *	GetPubData()
		{
			return	NULL;
		}
		// 服务器使用客户端的数据再初始化，得到的数据发送给客户端
		virtual	int		Agree1(const void *pPubData, int nPubSize)
		{
			return		0;
		}
		virtual	int		Agree2(const void *pPubData, int nPubSize)
		{
			return		0;
		}
		// 附加加密信息
		virtual	int		AppendCryptInfo(const void *pInfo, size_t nSize)
		{
			return		0;
		}
		virtual	const void *	GetKey()
		{
			return		0;
		}
		virtual	int		GetKeySize()
		{
			return		0;
		}
	};
	class	IKeyExchanger_Dft1	: public	IKeyExchanger_Dft0
	{
	public:
		static const	char 	s_szPubData[XDATASIZE];
		static const	char 	s_szKey[XDATASIZE];
		char	m_szPub[XDATASIZE];
	public:
		virtual	int		MakeOwnData()
		{
			strcpy(m_szPub, s_szPubData);
			return		0;
		}
		virtual	int		GetPubSize() const
		{
			return	sizeof(m_szPub);
		}
		virtual	const void *	GetPubData()
		{
			return	m_szPub;
		}
		// 服务器使用客户端的数据再初始化，得到的数据发送给客户端
		int		_Agree(const void *pPubData, int nPubSize)
		{
			if( strcmp((const char *)pPubData, s_szPubData)!=0 )
			{
				return	-1;
			}
			return		0;
		}
		virtual	int		Agree1(const void *pPubData, int nPubSize)
		{
			// 获取客户端的公钥，并且生成对等密钥，然后用客户端的公钥加密对等密钥，存放在m_szPubKey。
			return	_Agree(pPubData, nPubSize);
		}
		virtual	int		Agree2(const void *pPubData, int nPubSize)
		{
			// 接受服务端的
			return	_Agree(pPubData, nPubSize);
		}
		virtual	const void *	GetKey()
		{
			return		s_szKey;
		}
		virtual	int		GetKeySize()
		{
			return		strlen(s_szKey);
		}
	};
	class	ICryptor_Dft0	: public	ICryptFactory::ICryptor
	{
	public:
		// 自我销毁
		virtual	void	SelfDestroy()
		{
			// 什么也不做
			// 外界调用这个是为了删除自己，但是这个对象是ICryptFactory_Dft的一个成员对象，不用外界删除了
		}
		virtual	int		SetEncryptKey(const void *pKey, int nKeyLen)
		{
			return		0;
		}
		virtual	int		SetDecryptKey(const void *pKey, int nKeyLen)
		{
			return		0;
		}
		virtual	void	Reset()
		{
		}
		virtual	int		Encrypt(const void *pSrc, int nSize, void *pDst)
		{
			if( pDst != pSrc )
			{
				memcpy(pDst, pSrc, nSize);
			}
			return		0;
		}
		virtual	int		Decrypt(const void *pSrc, int nSize, void *pDst)
		{
			if( pDst != pSrc )
			{
				memcpy(pDst, pSrc, nSize);
			}
			return		0;
		}
	};
	class	ICryptor_Dft1	: public	ICryptor_Dft0
	{
	private:
		char	s_szKey[XDATASIZE];
		int		s_nSize;
	public:
		virtual	int		SetEncryptKey(const void *pKey, int nKeyLen)
		{
			memcpy(s_szKey, pKey, nKeyLen);
			s_nSize		= nKeyLen;
			return		0;
		}
		virtual	int		SetDecryptKey(const void *pKey, int nKeyLen)
		{
			memcpy(s_szKey, pKey, nKeyLen);
			s_nSize		= nKeyLen;
			return		0;
		}
		virtual	void	Reset()
		{
		}
		virtual	int		Encrypt(const void *pSrc, int nSize, void *pDst)
		{
			if( pDst != pSrc )
			{
				memcpy(pDst, pSrc, nSize);
			}
			WHDES_XOR((char *)pDst, nSize, s_szKey, s_nSize);
			return		0;
		}
		virtual	int		Decrypt(const void *pSrc, int nSize, void *pDst)
		{
			return		Encrypt(pSrc, nSize, pDst);
		}
	};
private:
	IKeyExchanger_Dft0	m_ikeyexchanger_dft0;
	IKeyExchanger_Dft1	m_ikeyexchanger_dft1;
	ICryptor_Dft0		m_icryptor_dft0;
	ICryptor_Dft1		m_icryptor_dft1;
public:
	// 随机数初始化，默认参数表示利用时间作初始化种子
	virtual void		RandInit(const char *cszSeed, int nLen)
	{
		// 这里不用做什么，因为是假的，呵呵。
	}
	// 自己销毁自己
	virtual	void		SelfDestroy()
	{
		delete			this;
	}
	// 创建一个加密器
	virtual	IKeyExchanger *	CreateIKeyExchanger(int nType)
	{
		nType	%= 2;
		switch( nType )
		{
			case	1:
				return	&m_ikeyexchanger_dft1;
			case	0:
			default:
				return	&m_ikeyexchanger_dft0;
		}
	}
	// 创建一个加密器
	virtual	ICryptor *	CreateICryptor(int nType)
	{
		nType	%= 2;
		switch( nType )
		{
			case	1:
				return	&m_icryptor_dft1;
			case	0:
			default:
				return	&m_icryptor_dft0;
		}
	}
};
const	char 	ICryptFactory_Dft::IKeyExchanger_Dft1::s_szPubData[ICryptFactory_Dft::XDATASIZE]	= "IKeyExchanger_Dft1: PubData";
const	char 	ICryptFactory_Dft::IKeyExchanger_Dft1::s_szKey[ICryptFactory_Dft::XDATASIZE]		= "key123456";

ICryptFactory *	ICryptFactory_Dft_Create()
{
	return	new	ICryptFactory_Dft;
}

////////////////////////////////////////////////////////////////////
// 利用DHKey和RSA交换密钥、累计des进行加密的工厂 (一般都用这个进行加密)
////////////////////////////////////////////////////////////////////
// 两种长度的初始内容

static const char	DH1024STR[]	= "30818702818100DA9A18547FF03B385CC16508C173A7EF4EB61CB40EF8FEF3B31F145051676166BCDC3FE6B799FC394D08C26385F9413F896E09117E46209D6923602683CEA100924A6EE695281775C619DAA94EA8CB3691B4275B0183F1D39639EBC92995FE645D6C1BC28D409E585549BBD2C5DCDD6C208B04EADD8B7A6D997F72CBAD88390F020102";	// 原始
static const char	DH2048STR[]	= "308201080282010100EB60DBD494AAFBCD2EAC6A36DB8E7DD4A2A64512A5BBB15B9BFB581C7C1CAFB647D4612973C3770C2166D75EEA695F67EA8261557591DB78BCF5A886AA5294F3AEE4D25B57C8EE8C7FE8DBF70C132CD7FFCB6F89426F807F552C5DAE2FB1F329E340094E4B30D8EF6265AB4D350E9837B151C86AC524DE4E1FC04746C668BE318275E420D51AEDDFBDF887D435CDEEF6AC81293DB45287132F8236A43AD8F4D6642D7CA6732DA06A1DE008259008C9D74403B68ADAC788CF8AB5BEFFC310DCCCD32901D1F290E5B7A993D2CF6A652AF81B6DA0FD2E70678D1AE086150E41444522F20621195AD2A1F0975652B4AF7DE5261A9FD46B9EA8B443641F3BBA695B9B020103";	// 原始
static const int	CNDHSTRNUM	= 2;
static const char	*g_pDHSTR[CNDHSTRNUM]	=
{
	DH1024STR,
	DH2048STR,
};

static	const	int		cRSAKeyNum		= 10;
static	const	int		cRSAPriKeyLen	= 3072;
static	const	int		cRSAPubKeyLen	= 1024;

static	const	char	* cRSAPriKey[cRSAPriKeyLen] = {
	"308204BB020100300D06092A864886F70D0101010500048204A5308204A10201000282010100C9A39B5CC1B3761D8D7AC89C94B2E6331F7E149596E827D8EFF6F16EA25DB76780F907E74CD15601B5D4146F0967A2CCFD40219EF9AE8F0F4C7F5BEED9503C0D38AB3EE0F924D7DC8E98A01620B847C7F14C3A752F4DE1CE2B3A443ADFBC377EC78CE227ED472E9B9B391BACCB13F23A3FE044825F16065E1D75517BFDF9C7E562C9AC895BDC32DC291F9DCBBA527F049572841E88AD9D405980E73B04169E3E59213BBF1FECACCCF85824734AB08E00FC17862FFAED1A2DFC7A630324830E626147BA006B490F86A7FA7288B219455616A7AD872015CCD72FC6EB238820D7A34B733FC7B81875741FC12B30B031DD328E548138E58AB626C105CC073F3F61C1020111028201000E3BBCA92ECD6BB9CDC0627D7FF488B8508764D75BF84B185938958F56C1583D849618A6EA51091533FCE65624CE1789F3C244A1CF5DA3B2C6271B925DA54982706C76E2B438CFFD7F864183115E535F6E65C1DE1B6EE8C948526B375B165239232B12F9C87778BFB09A9E90B6FE656D8603C899C47400731123631DD5B1414F5017757F923AFAF3679FE9A119B7CDEB45E20D10C7E61B70E32FA0BE00AE7DD4155A8223005A468CC35C150BE20610DE0611990A278455DA07CCDC6359E297FE6CB650539427B5135A0DD0AC62DDAB10963BC7EE88DF9F2BE4746FC676234ACE1992EA5627A27D18A545233ABD6422EBC24F9CEC14BEC41A9307FCC3BD9FE9A902818100CA336FCD330693EDF2C26934ED032C462D6621DBABA0FB193561B2C270F8EF899D1FB5E41990B17C257CE199863208E027B1D98FF7CC6C09BDCEE2513A16C25411C9D2265409A4"
		"31E0B3C81FB9D3A3AE1460785789FD5C3CBD84A48A2E9F5E92248CDF04FF8898FC911D4A8CDA7DF56074A543EE3AC1C58E3836973C561B5E3F02818100FF49E6D7913CBBCB4FAE7181E0F8C2E40A09FE7FCD261D67E6FC79F4DECB0D783829FCEB2C07BE86ADED6E06C27DEB82291709E57DF898937AD54E87C6623824A0BC75E4B9B790C2A0D848DED50154E7B1F84F7C586321ACA326171DCFE2D55411EFBE538711F04513FB18390553F91B839CB8E4DA3A6BCABB3362A095753FFF028180475D72C0E4D52526CE267F7C176A8818C4BAA289C41AB2F9D69AF3CC27DF6399FB385E50817E5CC267957CCCC5F38AA9776BF26F0C2A0803702AE677057171C351928667E16CD08A131246A1C91D8510436D57A66CF0026FCA6B0CE579DDE524855EE54D0EE4EAB37E82CF048959A1E5CED0EACC8D3554C8C88BBCE81E64032502818100962B78BB0A23B9C2E393CA4C6637FA2BC9AB86A587BC114C2D8574EA64EFE9CE3F27C1F3BF8C15B8A28BAA22180DD5D4182BAB77EFBF68CF39322E31BFFD8A6FE61481959A6BFACCD715D08313E2AA6A2C73F285612B40FC23BC0D9910DFC8C80A8D068B7CA123EC661B3B6CD5F5291F3E5C30869E7CB7E0AA5A764057EA9E1D02818077BFD52F250F8D2F7669FEF8B0F13AC879888E2A04D02B4E4DB49FCEA438333E66B650755CF041492240DABBF2B945231B4F2B7E3ECC151D3872D2B41312AD158DD9CB3C2B373F184832ACB00FAA5155B145816D74FB1C4BA5D2C7F9B45800682AB25E2B352AA4C475CBDC078E6CE58BECF5D187FADABC9EDCF8B0FF0A5F0E15",
	
	"308204BA020100300D06092A864886F70D0101010500048204A4308204A00201000282010100C393A40A455D552244C7CD57FCDAE5C770B37C7BEB4F9E4D3ECB4E00779F7A76DB4B723CB0E3F48464A3F32583A20F8BA41D77D04EBD284F17A8AF2E11411C019DE0BE27701B6FEB118705FBCD689627587DCC8D3DAF760F5C3B9D94EC4509E9B89F415D030D7AA928B5695277B081ACEF92D8F6602D5AE9C82A23DD73C1BC82C3762DE7DE62491A43A356EC2B8DDA8B1DC9C3CABE5B56C075F61F617D1781F6DF30B3BC8564326AF8E2E8A60D29EA169A1ED94CE35F6086850BA4A595EFF7C7C531CCAFCF451164F96163CCE7C904BC02BBAC913F34177E67220309F33735D826D4CBADE268B067542255694465095254DF46E2845BE3607EA7CF24571B2959020111028201001CC2E36AEC154139BED216AB0E98A952090B561239315B0B5C0ED6C3D55B37A81130BDF9DDC72B7CE19FA3C1C088C60D018BDCE9ED762B93292055FF3EC5CF69A646B28D5440452A192A71D234CB9D9C5FD643BA6AF427F33335F186D773908440CC20335345BF36FE7507F58A126D6C41595C243B51F6C806D9054636AB8CA98F6BBDA2542A21534E175D223B0B5709D3086719BA19E4F9574B41114DAF5F894F015AFA29A3BC58292D5E63A62ACF48A62305E50A68DD5F3BC3DC351325C5390665C72F2EA397731EE816CC12E9C2DE11DFDB400FDD27916D117335AB9804CFE8D8DFEDA90C9A94488C073259776D25CB6BF58DA3239B2C6C8237130B234EF902818100CE4381E0B3C7CB87C8DF8926A3CFB1F8A0BF6340FEBB8D689B4A33FD040B5EB3E4883BFC0EA07E35B868716F0B0BD9F1E9A804740CEFB474E63B0050ED57B4381733A42681B04C"
		"2B52E8AD33AD672BD3727F86BDAF97B02DD69EB26E01A884765B588A18D94CE4BF7821B32B25E3D66ACC6B779567008A0795BC5E742575323D02818100F2BC6F50EE48CE28CE24EE0FF63DD8B61537A37467BC811EBC45CA8868CA0003AE38D9E8286A4D10F545F55E31C7C1D046BBDFF68FA6978A086997B88CCAA00BE8E3AAE2106F8C2AD44E81FA535F789C16B052ECBD56270D44730DFBC91E90A8CF531BAB585FB08455153E1AF1551980212F4989FB3606F7A0A92D61E5E9114D0281803CAA717E52FE8727EFC94674C6C49DC198B0C2D6E18274E28806C3FF1F4EA3621609F3865EA7ACA6636A033EC7037C5635A9E33130FB351352C60F26DC6516E3521E3F569E9D4394458FBA789C69A37A6CF854CE60D242E04E2EACF32DAA08D7844737ACF49E2529417352D0748E4E1F694CC8D196C3EC5C9573A34F564FA55D028180723A8EBCAC5E7F2242E433CB46B3B146A092A745D676D359C202B9A99AB9696B24CF759A6D5F3353463F0A0E358B2E07A8D0E1DD70C6DDE69A8C0B29ABAAA5AB406B233D34E932E6FA7F4C3990A565EF19BC63423AFB5DABE3F9E8767CC316E607362B2374E1BC7A8264597617371B0F1EACD74FFDBF125669B9064C2FF535510281800421A819B56F31CB4250FBB002FAC833B9CB3BDE4742F6FE3826ACDAA151E772BD9FEC9B56E440BF723DE3A17226E3B567AE8C06B1FC26573D9303B8938601D46A77D4C385F2DF3D05D2B402678D71AB060D7813797B32250BCD6F2191F49AD8C0CCB546A51E742B0AA31A92665F24DB8F2945DC4BC6C949BCE5D6615BAE7149",
	
	"308204BB020100300D06092A864886F70D0101010500048204A5308204A10201000282010100BEE8267BC5545160CC8E90844BB2AAA16AADD54862C2FACF4BA71FCB8FF08695452DF3DD7CE86A8F6C8AAE4901BF440CCACE4589A353BB972C3F220C34B290CD0B69D36AC77B2070F82918C43BF4B951629643A0C84D390433BF59F5CBE8B486A78969A5CEF04B7FD9431F9D71BD7AD0D9BC98351D250CA451EAA39C37597A1C0B8D28ADE05727807D904987D5C3020B5E9991CF966B9E16F25ED4E361E5091EB81967AF3392B247FA515B835D12717602FD3E273CF7567DBABE773D9608DF50E0A1626C9ADFCEE43CF6D065BC88C77EDDE708AE206ACF5A7CA578AE149AFC536200426E2D9FA9B1D29C0C2D148E3F92A6692106431B521B0748A9D5F644A04D02011102820100086C1FD0C12D21B53633775121750F0EA696BA59C81F30B652657DA35568BAA4B3FE433AB673AA5926ABC3ECA1F59D5AEAD464F33FAD1B197E2FF6353E8F684548086EF96AAED804FBE3B208A84ACBF0C45973ECBD8AEFB120668F435086806F5A3700E56EC6D62785D20528D413A74CFA8C15C61BA384528B24B46502711FBD654C926F1B73C20A6D99C076E52F185DAEA6774C38A4D64BA190D289B93F9C927A01314B1F68CED7CCB7D3DC92F3B6AE0FA2DA7B20FE8BCAB48E954F34F7BAAD9C71B42C611532B82D4B9380F34B564E4EF503C0480C72681ED49464105F44CA685489938FAB2C82930FCD74212F30BC7C1F5EDDE17766E12ED61F9F1E0B8FF902818100C16229F5397E7454FEC61D609CD52F9F38D90B124341866CA4CFA4E16E01FE222DC7780C9A7B8712BCDC142573CCBD8A211E00DD838B025FDC409CDEF1BAE16E1416E8A877F3B2"
		"FF8B8128599C8B87FD4ECD6FF8525B30DE2D64FC462CE47BCCAEBD08D599C3A06BF96973BB08D8AC2A8286E6C5A5F32664E69B0EC0089786B502818100FCB8B2378DEE2F94752D21A0436CFF760458A152F9E71E4D54BC8BD037968359BCE19251267A3019C7D92FD63BB1872D2A1E8FB822E29E2B37334CB09E5ECBD8F2793080DFB648EB596F434BEAA6F0929167EE5A17A027EEE9C358E11F4713F0211C6087DB5EC30B7E771229C632980D26707E9B5140651B5062CE5499FC5A3902818100B602095F452BB8C877510C972A320EB3F944BF203F4CBAC09B1DC85BB2D4B2F2FDE8E9754619E88A1B297C5F7C0BFDAF2E3A5B2AD6287AB4930FA2B3B65588E012E8628070E55D2CBF889E7275380784FEDF78713E73F1C20C9B47C993A9DDEDD1A2DB23638AF15690633FBF176283EBC6249CF641D5C9C86091EFC3CBD9E8310281804A5470A6ED824A3AB90D462013D4C39B2E746BAEFE34EACB7346837979C2DB56A0F70CEAB0F6C2DA67F495995CD9DC76B208FD180A42A6FDA6D2DA5210763BF4838D0E44058FF754477B13CB08C7B02B1BB527FC614D38EBEA66A1AB9FC99C73CD80D118E62AEE12707D5FB1EEFFD25E387B708808D6B45353E0D3460F2C1A8902818072E88F28ACF0487B979088FFBA16CE364DE0547745A329CD001FDF13DAD412D3CC6AEF4BF45DB976A07280AD32FF46BB05844CDA0877DABFBF969DB05B35304020565184E0B4608C47752CFAAB73E670F09693685249E592068D0B724DB3EF6F98DDB20285706E21F6049438A476786477362F984616D4FB933BB06F61F3DCF4",
	
	"308204BB020100300D06092A864886F70D0101010500048204A5308204A10201000282010100A7BB1A552F0AC99B23E29841DA6A2F997B592E41EDF591CDA7AB3D8800403E69D37580B2C28204F1E8DB2842631C0BCD8BA50A40373AD7AAFED143C5C3A63FA1006399F958B89E78FFEDC56E8871C3A9186FFCE96B163C56AFB0328FF86F33BDB72604E3BD86E55C8F0C5006BDC04FBCEA69243E83ED33CE222BF9ECE217753EDFA4C9FC23995D4115DE3A82F6E170860F59F11DE9281BE85FFF6B556C0F33353C65ADFC1B830185242BC0783972A5B12D1A246B3AA1A543D7F0975A51EB3FC2AC600F1FBCBB157DF6FEFB1C42A55383F0AE18BD45DFFC5D49348732724FA10E749236EB20A8C8A75278A2AC4999243C8ED6A0377B5D771CDBF036811D3C63B7020111028201003B32FA3C2EB88363EE8C35BCE3AD01BDB3106AADDB83D91B685A8E300016AC9DD22978B78FF1A764704D5980D7AF8BB1F50D12AD40AB5B2D4AE07245CC95076600232748F2230AC14B44DC45211917E153EB4A3443E9BAF16B2F20E784DBF424D73A985061026F119BE63A5CBB710D157FE8DF9D97F95D940C0F8562AA26659D260D2E032D54BDA129787D1BDC263C980CDE510038A8C7B332340A97C7C3B840D3C23B3BB5415A7CB519B534E783E49126C2005B88734F0F2FAE90612D78E5122DD85497572E428B656FCC3B01B4098B25E46646E3DA88B67B52D3074882E449D3FFB03B97DDD7F468B3EC5EFAEB0DCAC97A308D6FBA3F45C25F96210489842102818100CBA44B76BB14919BCD919ED26DDF796CC2A1F94ED98912A49E90BEAF2D26E25174046E946180FC76FCCA06659BDFC36C39E02E728D05D37781CE8ED02E5CB35C05FF79BED6AD6E"
		"350B1D55352A24CD0450518682FF5C1CA9201AE5FE7173265C6CFBCE4E2209F872FBFCC7A4A4561371E782DA72240295C0C976E193B718A79502818100D2DB26D1BD6A07B1FD773936EE95A0BFD2ECBCF919C0D372B3308EA2DE3DC6D6C5BAECE9387384ACD0EE38A762F285545ABEF4F555AA71CBF9B36F76CD62AE0879D0FB096F0A9568A1CF8DEA93AD16200A5570716B98B1AF21044B4A08BEF3E0D9974A9ED054EC552DD367FA88FE69B6C1CEE6DF4575D8C1166A80E52E9E1B1B02818100BFA9B06FBF226AECFDB63B206768EAC0B72F08C2AE9F209AEF974A0E489D113D9A5E86314CB5A251DEDC424183A56CA2185A861175AB21616B1CC2A5D14830569C3BBDE0CA0CA3F5B01B9B7D54D7578B96E3516C3BA1FCDB6982BA58E33F3329CFFC0D76B69FF8E4B0EDE9136D7E306B343EEBB6B87AE74C08E85BD651F916310281804A6B771CD970B76BFF1B05227252ED70E10842B245531D73C6C5D7FD3F6119008205BD0704DD7A1EE05413FED7A0E3C36B527492D2F0DCDE945D72A2669B4C7B7649C203545E169D664941259D8862296D0F18A08054027A0BA729A1A8BBDD9AA726569267A5809688A4F78599C3345E9EC17EA92793013516F869BA4CB045CD02818021CF390E0A170C31B1903D5B1881D913FE22683BF864A7EDD4FF6611A869F09FCEAE8402F43E9957D49233CFC18AFE7E057ADC62AA09CAB2FF36438B55D1524681F8ED0A55705808C33E8C445F0FC5FF258C13DA6D2AF4F3C7D86EC591841EF25FF094A75C7E96DA0F28CB42F8783DC9F4B3221C743508DBD9C49BDB4E6C0FE1",
	
	"308204BB020100300D06092A864886F70D0101010500048204A5308204A10201000282010100ABAF06E6F1C7CBBFACE3535260588573CC90476137D3F29DC7239982FF475B03FA61EA0BD2EC3C91CD6F799E97940098BD08D098668DC3F2A8CBE386BCDD622FB6F3D607A86F5DE89E6C7C4A20DDCD5B32B4F7B5F960670B5217E3BBDC1D81845A9025C41D919F4F2D8EB5A4BFF1FA3A8A4332893E986FFDC105024E3AC9AC52509485F6B8226DD407AC04A2EFB9DAC44DD90E61A0CB8E11A9E5B604577FC8BDD44A74C23F594D8F820DCA8B2B61129DDF6D452D85E01D122D61CE1EF333B3D450901EBC7924BEB6E6A3706BE34625CEDCE93EABFECA15E4FDB459BACD0F31B3B31576E4C551FE9BA4CBAC44BD91608E429AE13E4A915E472F0A26688E653F2B02011102820100327EC5CB7449D283AB51EB5476B09FB8A593D8C23D98B0C4FE55C3BD1DE7CF79A3FEAE3FB681B7762D5D05A71D85E20ECE2FC4E187931B839B0ECA72EC411CE0DB74E498D72FD05379E3AC15CD6E69934B262ABD0D1C5A8ADBE8E8A0AA26CBBD840C4757CC761FCBFE57265DA1DDC21137B969376CC36C3B931F97442F687DF99C409E58409DED77603BF6253088996B0F935CCB3AE9465E2C9D3C1F9313D854FA80C4119A56804F335CE7BC144273C907755C2451A4B1C5D94D4842EB6A46DBEEED58F4CF629599BC676B0B2CF806B138ED4AC2895FE5D98D3907A8AE424FCA2875C5193A04EDAAC38A6574AC09DAB1E293AC23554B6875AE93D1C15C0F44B902818100DB61288AF7D3684320E4945BC9E5CC36E73D28F5198092A271DEA80EBE5B567265072639EDCF53341768BFB82AED9A32F046C91DAFEB4BB29310D9E152C279E8219D1AE8426E68"
		"D775EC50773C2556A1A0F07E12B57FC99F11B2291F8C85A95E8265E52BAF1786018C8222A15E0D241ABBCC4A8E874B13B194014CED4BA5CD2702818100C857A972E49C77C7D2C85E9580D06B54980D438658983F6239F074BD71E0F92A81F3E71944CA461AEF35F6ED21F7EEBF6F6442C78D2B41BEEAB09826E66E490068FF3BC70F33F2D4BCF11A68416F1ED2AD9EC26A43043EC8A5737CF75674DF72A71F26C9B75CEA224C3FCA49E362BB49EAD8809E07AC4DD24978A9E9D68B885D02818100810BF9BB285E3D54A9EFDECC94E1872F5AD8AEAE4B3C927DAC64DB53F78105ACB3E6167C6DC54000863D9DF3DD043C966F38B289EF02E13BDE09E9939A180B797D2F3D011804B624637BF318F63414D78BD8C2A197F0D0F42886EB037FD62764C52CE128C15921A68EE3236DFB16C9F19BA559088BD1CF59661EE1F4FF5278AD0281805E475ECCA7D1294EF9C7B40A1E803282296FA74E47CF2CE2EE16CD8653B529F5E2CD21754D8C5D39D9FB47062E1A523BF82F2E7C0632794AC8CB92E52124D70F40781C217090EABE77080C6D4BF80E8142A51032016B68D6E472952919A06926E53BD604928613D3E7A58C5F0197DFAA5065E22C3FD89D17AA1AAA4FEC7DE5D10281801F998A2931996506AFD929BC33C93F6B884B23B388172FCC44E7C3A4034762E9D575F7DC1BE6BD48DE47B04DEDBE1162F2990EAE1B175F5AAA9DE08896E4F5411F8DF1CF8AAA401FDD5D622345F8E16106C8C8B12D6FDEDAC3CDC0F2FBAF4D4D0B433E12DB3CE7BB1BE9FDEE01860EB44DDFBC3DF2CF0BBB0449F33767963713",
	
	"308204BC020100300D06092A864886F70D0101010500048204A6308204A20201000282010100C801619F66A756124DB81D8F27EF75C8BC7A59F6F6141265B32912CA395188D428CB6BE430F920A2CE63680A8D7D14740881377E65B441E6428BE88A7B1B9959C2A29375C4940B6E610015868724AEEEBAF8688A44A9DB0A8E99F4224681D76B3D2B272B9B49A8190C01083F2BD28B4A119D5A09C4F5FE28601250B2F2FF10C9B11FC2AFF9020399909ED512FF27CFA091FE0288960499E2637B790DD646C653B81E90EE4DC235A0B4B29304B6C802F04DF118AAC02B84D5C11E473B5BB9C13BE44D509862EAE18FECD84615F1CBD45898F8F440B2E584BD9385E8F4D826AE2A1B4B5019919F0E33CC06C243F83A51DA20E022157C701031AE3971EE7FA3131D020111028201000BC3D890E7EBB9C4D7652EEA4DA4AC9356618CD24AB5E2F6EC6BD3EDC722E9EE5CC0ABFE5D3BD4BE4860334BEA3488BB880799DA4237C7A422083ADAF82ECCC90B72F99D8408B560D88788CBAD98BEFEFBF07E9EB8BEB288268186D4D6F894337C1198E4728BDCB62DE1F16D20B208318890C90FA22C967AD8798C46C2FFF1EDA47AAC193FD61218E66BC1011B753C618C2C3979D50D0762ED058FB33464DD0BFF0B67070D44372B631203E72C9967DAF3993AE33100FCE2083A418279872B7258C8F1B5F5C947CD44FF3B94059A50092CD578B3E0E7E905F56E37EF0DA29920E9741592E67790C3561C0BC8974E9B95317A696058B6349154230AA93EDC46AD02818100EC478912196D47F0A976E7A18617D774567ED184C6C1BC9D2EFD8AFDD863E37271B3BAB80C73386C7A7DE43656A2B7A18125D2856FF821D7D7889DDCFA2165F426E1CFE64D7BE2"
		"1030096B0E276B851BA3ABBF1D2DA997FF8FD5D9D08BA8C424F148FABFC1C84CD4B721D353F6692790C2F7B81F87909FAB00F0F8B9CE7723EF02818100D8B2CBF0A25D88019A001C5EA646F5B1EC8F5FECA9655FB3771F63298330351556A8FEBE5FC75352A6026C7469F565C49F9E5D0F0F2297FB5DB74FB44F9E78AFD813739CC3113ADE27DBE6336B20FEA0FB20313195D57358B75E584464B1BED5A94CE69881E624665D08269DF598D56114C76A9010C5F2E016F4C3F7848B3DB302818100B4AF2C955EBCFAC7182DC030395D86A44224BE5679DF721DD8A3C4A3FFD3EA2A56F2DA1445C18580216F54298D8B7D5D62C291ED91DBDDA50E3B4B8ADD64D57E78161773E0E64375CA618E19E1E8CF3340ECBF528C54834AF5856A542E901D85A9740B0B1BB749CFD7561A1307B9D2F63ABD6EAEB2F61FBF00B845BB438848A702818100A5B5E73F8B3877104896AC486109163CC3F52B3C8189C1A75B1800892815CE3D7E813B46493E128A7EF2CB6814CAB73C0197381A931A7438B113B56BC46A200DFF966777E076966DA60282DC06A0C2B756A0259E63851BF88C3916526B1E82DF9F9528CEF9EC39F3ECC9FF69BBCF39C2B5896F9B581EE6E7991586CC564C5C5B02818059BA97EF15596C145F9F43C1403B8526D21DE93E9221F31348EE0966FFB16437C8C84B61966AF64602F22D0A55FBEDCC73D9F8457C68B4FB019BBF6A2396E6233BAC8AECA4EE7E7B840434AF363A84F5692CF39A7E8F10259C3B81A57D448FA86BA65C5C826EF42D99BB7892C93156B7A30620AF6EA064E012E777BF5DCA71B0",
	
	"308204BA020100300D06092A864886F70D0101010500048204A4308204A00201000282010100DE07DC9B2F70B9EE981480370C3997059E7D9D8DF84D27E397A5F61765A8C5EE8F5DE3D8A083828D1289273790B438C81431616B6F6AC1E6BAEC469E9948F18970E1D275C74D25C31E16B38D2F83541EF7B0D72DD3448CA8EDADB7E99FA6405C038585459ECEAAD6FDEC0BCE6A4BFB2A4128413480BC39D7AE0AF3FCF39581896CFB1476BA83E5291B891AEA7B1D7BE9E543404BDC6C233646C2769E7C4B5DF1E678340BFA632F5C1230BD3E16FD2A73E96AB74598A09D962630A8A9A3928F067A4B2994EF7903C84A671A5B02925C1BA1D1030EEFE06D2342F967EA9A072E5B245C55BDEC2BDE238F3FC2213CF06611DBCA2558B2D6514C104A1E81254CA2DB020111028201000687C2B94528F668E65AF4B6532EDECB759A48660ED517C2EDDF3BF1A11B8D59D70A4A775003DE31535E630929E72ED8B54CBF19BF8323D2148E7A8C31AF5265ECBB590376CD902B62C46EB15438918870B260AE8636B8D7CAC1583B93C12002B4CF38A02A515F60AD1D87E06C89C39F5C44F2DBE5AB2EE0B24B9DC3ACCFB0FC7529E1D1C6E4BD3DCFFF432F6C6C331E72B67DBB08A62CADA8A6E80805A88FD1AC6986E9FA58ADE4247CC7C04D8B6B28CEC70A8D10405414AC2277DC279C67ED8CA7B0B9CF44045206EE321DF512BDF9C615A00651028915019824BA869467409DE840F95DD64410A751FD8E6AF44DEBF4C0459AEE3369261D269306C547306502818100E2C8CE7D05A523B6499E5F12DD3C2FDC979F6BF1ECE10656EF040CF3AF368C90B6EA8164C27954A0DC37B4341EC30589CBEBB0F57A8DCDE3E7C5B5650A10649705C2B40B5AFEC7"
		"3722170B64B6401556A8A513C057EA950B82DE74BC4C503CE7D70C43A3AAE0CD732AD5DE6D10FDA7D08ADEB2DEE8260603B5219464B7B4BC1D02818100FAA2481D4A7D9F3D3203CF8B3782820211672182C9792DCEF193989A0CB1B7884989C793F822C26E5D66817FABB5E97EA70F9F93F587A4F361D7080756BC5CE2C642FCDC0D71A9AC3CAD66FBBFD50B98AA4CAE77D59FA34D89E612686E013ADE547770FBCAD6067A2B8636C9F78064EACF6233E627DC54387C0903363A2379570281805D61BE6FB707C3692D5F54530FCD7D1E98C92C72ACD520BA626B14645734943B969CCBDE31F5B96F69BC957EDF7D7AC044E89428D81C45B8324259C031520B4D3E9B774FF84ACA801D188C3887479050DC07BCD6BACA0122DB88C6A7E33019142B5F6725465C90D511A35B96524A5428B1A6FE5BC900991095E0A683D32C4D75028180587582DD2959837F0297EEE5D75B3CF1ABCA0BD3CEA33D581906EA90B92FAA3019F4648E93D0086330060F9678D6CAE16823A1BBC011C1BF4FB54E20B5336C13CD810DF35009FFA633887EB334A58B9F4B2A1F7596B0D0397BF6D95208B523D5FFB1AF67ED3C7AC1B502317475789C16A38C12513B3EB4502BC6F21323940CB50281805F17FA79696299EEE8A0AEC9FC345821D6FAB5C22973DEEE81661045535D89EDE5CC97E117E9AB82CC973F1AABCF0894062A8564921B92EE2C6F48CC7F6DBF90698886EB2E4B9185427CE9356095B3E7188F2FA3541A246834CE0ED88B6C4A185F40E0DF28C64DB73EEF77D77621781103BC4C6E80A7BBA1BE54A86CE5B3ADA0",
	
	"308204BA020100300D06092A864886F70D0101010500048204A4308204A00201000282010100CB1AA45A9A73670DE75B0EEEBC0C15F78CAC03377A4AD2CAA393A8565E12209E799CDB4511DDA5145D2FFCE98A0506103AA77426F5AC6C9AA6F8A892D6D48B24525BECFBB9CC924E370899D91B17B62E8A50E07D4ED9136747B173B09E9B6B7C1346554CB674EE3E0F81A975ECE2F579B56E2B8F02F1108B3B7D7D6A6D803BB4810EDC010431A509631F209B75F143D22E774E2D5CE914B58CB085C2624751B65B76A10684BC6B5459473D5CBB22B17B6014E2639B213C96E5D330B199E25843FA40945BBA976763B8BE629AFEB131C549AF3FA474164BDBDE7A6D9B28BD9D433083B4418D245538019B4AACBB070406030D97173A7DD943AFA482332FDC189F020111028201003BBC8AB13C7C4B7C8F570464556CF766ED238879BA8E7A3B9985C81966F645D441E2D714508C7BD8D01D2C44B01F985F204F5E65CFC94D1E6D5831949989CE92365745B372E1D0AD97B73C4EE9D9CC2BCE5405CA809A32E224252206C53CC5429C41DCDA53C809D6048F8C31BE24A28D355CA3664C28C8A16BD99D5B899E2FAD087B4FA67069B084BAC7113370DC400E944CA1F6BD8AAB1D0DE6704D592EB37B5BE94F759C54249AF8D8CBA0D79FFAD5917F9D616901AFC6881F5A611D164201A6B1A6FF95058FA2B746C280B43C929129FB5A2B8D087053630FF0B050C3D61942ED7CD17138DF61D88D041721B6B6EF5B0AFE2683ADE0DCE0757AE8F383330902818100CD0D0DE70605C7914B82EA8917D4B0F2135C4154A1E79ED528E20C712D501A4AC9E2F81D7921A379A909484DC50F804E948BE970064F417073A85D3A1F9AD1B8F966119F63946C"
		"BD541195C309B79F52E87DED06B40AE7C84B1D4AD080F1391B93A69922416901BAD070980EEBF9B9036581514C06F9B096FF8568D75FE024CD02818100FD91BF4A7FF7B8819C90FB96AB2FB914EFB0195E9CF6C9B0CE2561E3D28BA1FB59140125F8164B656229A71F4C2675F0433D7B752FCC3F1D09C039C6E42F0C8563B1B1575C5678B05BEF6ABBF6920684D274533CE0884C91A8F3BD3FFB98F29E861C0C57312D28CA1DB1A4B58FA0103B34CD4C150D682C241B5C7776FA71131B028180242F7AEC88979BB03A8083BDD7076A851279B12D0D833A259DCD89B99E95AA496EEBD16E9CE7D18DF0A748FEAA4E079565821A22D3EFDE5F23781073AB39704DD1A899B2B7384F6CB47B92E62EE42B2CBF9DC06A983E28E71C50769D43EE555F382C756065E55AA87F22EDA847C2A82DC69E59A4013B1F29B49F12805C369D150281803BA9D2A81E1C2B69CA7C776EBEDE0D6E5683C9BBE8B289CF3F905344AA02BCB39C7D2D72587DB7632627EB166C4548ED3CFF6857CF02E1AC7AC3D15BF9747B6AAE0BB141BB5FA3ED42CEEBEFFDC80188A9FD40C307A7998BAF4868C3C2BA93709806997DED740998F7ED902AB861E5B393F411E6D5FA64BD339D49492BDE5ED90281802EE5EE4A75E320773F1556DCBAD24650F015E0C24F022614AE803DD22653C09C5C2CBA4F6E63B09489B9E95C9599911BB758C9AA0958F01631C109F549D3F38F84048751BA91AA070480972FF48A1E195A3B39CFD86D771F7367073608BCE1A3056534D0EDE09BF258C7EE190934DA0D716BB764196738514CE6CA7B74C1D3F0",
	
	"308204BA020100300D06092A864886F70D0101010500048204A4308204A00201000282010100B4F7AEBFDD39C85C3D2D626D42C2034ED801E4C9EB867C2E4E432B4D8AB9C44BF852A8070477EE71927034B72564C04C8CFEEA21522E6C4728384438BCED3AD8424AEAC49A12199B52F0595A57521155F668D93131BCC071CBC1A3E3D546A718621608E038F16CFC24F581B043950E0304887EF05C3E8FE090A8D52CD63E1EBDADDF46C80E5FD101E06163FF7A2CD7481479503746CD50E4F3752BADFFF2FD84B9B07B03E95A2EDD2363ECB9A97CC652171A2245D7CA7ED12767413CD66A186FD3ED41CB78254F1554EEC2B7158F1EBE400BBDA1EA9B4AC1A5B98442341115588444BAF6149A43D38AAE0FF9B2B2D83532BEAE3A44B51BC20FC7BBD4B3EE101B02011102820100019EB2AB4AFB9B53FA0014321538BBF002969AED82C354EACEF0E34087CA02BD3E2179F983F7E845C3704F0A26A2F2A99B1FBEA89072FE59AE30F42BB85C79FABBD8BB63F836813618A3DEC0F8ECC3EB7D9F62309028A567CFBCA8C03D298D9BB78C4F4D4D1D014D8D191CFCAAD5CB6B672929132CB156672A8B0140E474718B2D2B316D199477AA05C243735FA0C5325032CC9FCDAC4993473201A5151F0D3A4E4AFF05E17D3129D302E70F7BD9A24670B2D2C3AB57CCC8F77DF6E86D47093150111B97158A3A7CBC247128518B343D8F69FBF59EB7EBE9B1426E086F08651276492DF4151CCE2328ED081152BED566081C5A34B755C47D3DA28F2D9B0A28E102818100DEDB270819EF720BD479F277D5041B4D49EE34BCD59957811859147957177F7C6FF1419AFCECEF92E16464AF8C1BEEDCEA33864822CF1704A80208A59E8D7ACF2A3F0FA5A97840"
		"DFB6A25C54A4838A16138FAD056B9AC72D9745CDC6554C3335102459294FF5C36F8BF4531AC4DE8C7AB8EEC450A59C46149A24F127DAF26B3102818100CFE1B2B63881DD9F888F26E5A100652AA6A93DBE1E4E271EC992CD2A95E0DCDFD629A68ECF3938C0BF4D8EB6118C994A4802105181CF7819A391C2978801761BB9127112FAA41AA25F89E0812495A4142960AF6D3BE26C2B8F768DA921AD59398CC378B6FBC967554749EE743FB2077D38DE437AC286CDE1B4B298C60C43850B028180418BC02F8F284EB82F6F29324DB5E9E98E370073C65A46E9BBDDF6F68306E942B7833169D1EB55858D95FF7EECF92822DB7890E80A3CE8A7043CD55DE356C9C475D64FE56E144F50DB5CEDFAC6F982F76F2A41F2890F67C21D6EE22B4643969722DD83A2BD2A2A6C1A1AAF07DF8CBFE7DC09FD8121A66EF70028FBA24F7479E102818024AF5BC5CDBC90859091BB91EF3C4E1695E1A17BE73AF7D841B07E8F0B63EABE16BC0E556FDCEBE5C7680A202136EDDFEE96F3D225F76F8C0DCE6DA2452D6F321199D7B80E1CF5A42EFA36AD60CF1CF47FC5C49ACE552225CE05DCC37E69E291AF6DCA022C6ED5FFFD85846EDE105BACAFAEC09D31631545F2B61AF5C5EDCC2F02818061B6516A19F96089EDEA33284088DA9413C0B455C777A377F2E80ED5CE52BCE2DBA074A6063F408C2AE2D0A2A27D6DA16C2E15D3905C8E24A81DC977FFA70F92FF8B4EE6F4276C935ACA933D22E4D834F732B08E9ABF12E47959A5ADF3329D5E950C6CE9A98506BD9F3B654ABD851BA9D64907809C3F965E70245C5D1D0AF2D6",
	
	"308204BA020100300D06092A864886F70D0101010500048204A4308204A00201000282010100B25415E401B0490220ECC68617FB17474E3598BAAE6F94632D7081A20401AB1C4082DBDF9A889892415F1987AF8C381231BFBEFFBE6E0F9649CB492B365D33A623C3E20D5BDC964DB9851D968D661786F785BEF39BDBA9A710305958065370F0B805FD26328E6FF0C78B007CB2D92020D82E6980CDBE8C0A69C432906106BA193FBDAD281E3CA6BD3BA69EE31523DF811CC861BD52041EFCC2AF25E8451CFEC78C2BA6A0FB2E3F738D60EC4853B38646838468CE91A8EEDF3A2FBF0FD561DEE15AF9EFC1520A2EE975F828CD038F85BD01ABB30C7C4024C8457C21B39A42876AE3CCFC5ABAA8CA8CDAFBAE1643A7422DA11CF37AA04F0718CC2002640A7AD1A102011102820100037F2391050D7EEBF69B3B1BBA32198DF2798581268EBCA29275A8305A6E76CE5B9E2C77D5DA85805BA27DFDA411CEE7423AF9B4B36B91DFCF4038A67E8E6062A1542791D49FEEDE63029C3020E3E257FAD06D27E9F53F8FD32415D48CAC4D8235CDEBDD9C996191452AE1E453D20FB0548D7585090DC682B6C79C996B5072148A699AAC3FBB01A3F9D99D41749E9E709540662C75675953550DA33C6A2816D17ABCDAA633492CF512DF38449A57AAE4E70059CBDBF4BC2E9379898108EBA2997A9DC06CD84DF3A3FE3AE9CF22237A532EADF54EB709EA5923D97D09161D50865E49DFC77360A2ED099E7ABCE8CD3CE6BE8B47DC50EBD3348ED46766AF3E8D3102818100C53185840F4B6F173B6B002E2A1D879E4DC47CBD8B8F27B8FB8500FFF3EE6DC74AC859A4E0084D792DB78159A1E43950EB15ADCFB6D3144F9A72EE42760FBAA901D202CACA0755"
		"BAF67BB6B4B0F43C7E15C21571AABE3F0D9C593C38AF5506B0CD1664CE77A3E9321951B8DFF18C42F186E1A8EF30CCC3DE42827BE5A283B97902818100E78257535CAFE3FB39E14AAAAF6CC775132F8A2462DE2BA9D5729FDF2B320544CDC3BDDFE391FD279D313543F258415B935CD76209145D483E866C189860BFA4EBBA9747707B4F82D9BFDDD48589EAAC9F41BEEC5A8835F884CEFCAB831675F54DFF02D046C46C21D7178193F137DD44247BF9A750872FC2154CED097E80F7690281802E66014C3FD5838CFEEC000ADCBBA7708AC4D20E7B30BE0D685B87C3C0ECCE893EC5BABD61E3D5FE651C1E6F7162E04F465F7430DFB931F49CCFBF972AD68645E24F882FB710C8E0B2777648A21B5987142DAAB15559F0B7E88D7794DDF5E374E4F635D63A44AF5715042B7FFC997929C56245DDED5D5B435AF18690627958D10281805F53C99ACBCFF476813EA646483BD9A8AD8C0BB4A12E4E36DF6B6F018A41C5EF278CD5B68AE1C297D7507F58369CCF9E2D9EB30A3FF9539637DCFF556BEB9A34D989111D6A8D20BD68B86A669156E828F6483F8E7FA17FA29109EF91EAAEE546E3E179A10E14A4FEE018BCE290806A2B1E14EE53F3FB6E049F5BE92206E9CF4902818024866AFEAA3ADE27437208596D32DB4BC91A8D0CE6847003CC36F9D5DD172949EBC3FA75C3267148BF7EACEB0CA14BFACBF2BD55FA946D24C5DC130E66A0C13F6CF4515FCA92CEA95B0B9250EFC40363E4DF0B28109DEC0AF872A7F94BEC8C7FF9B834171E9AF62237E6FC9DDE345565EC0543E56AAAB75D09F36FC124561C07"
};

static	const	char	* cRSAPubKey[cRSAPubKeyLen] = {
	"30820120300D06092A864886F70D01010105000382010D00308201080282010100C9A39B5CC1B3761D8D7AC89C94B2E6331F7E149596E827D8EFF6F16EA25DB76780F907E74CD15601B5D4146F0967A2CCFD40219EF9AE8F0F4C7F5BEED9503C0D38AB3EE0F924D7DC8E98A01620B847C7F14C3A752F4DE1CE2B3A443ADFBC377EC78CE227ED472E9B9B391BACCB13F23A3FE044825F16065E1D75517BFDF9C7E562C9AC895BDC32DC291F9DCBBA527F049572841E88AD9D405980E73B04169E3E59213BBF1FECACCCF85824734AB08E00FC17862FFAED1A2DFC7A630324830E626147BA006B490F86A7FA7288B219455616A7AD872015CCD72FC6EB238820D7A34B733FC7B81875741FC12B30B031DD328E548138E58AB626C105CC073F3F61C1020111",
	"30820120300D06092A864886F70D01010105000382010D00308201080282010100C393A40A455D552244C7CD57FCDAE5C770B37C7BEB4F9E4D3ECB4E00779F7A76DB4B723CB0E3F48464A3F32583A20F8BA41D77D04EBD284F17A8AF2E11411C019DE0BE27701B6FEB118705FBCD689627587DCC8D3DAF760F5C3B9D94EC4509E9B89F415D030D7AA928B5695277B081ACEF92D8F6602D5AE9C82A23DD73C1BC82C3762DE7DE62491A43A356EC2B8DDA8B1DC9C3CABE5B56C075F61F617D1781F6DF30B3BC8564326AF8E2E8A60D29EA169A1ED94CE35F6086850BA4A595EFF7C7C531CCAFCF451164F96163CCE7C904BC02BBAC913F34177E67220309F33735D826D4CBADE268B067542255694465095254DF46E2845BE3607EA7CF24571B2959020111",
	"30820120300D06092A864886F70D01010105000382010D00308201080282010100BEE8267BC5545160CC8E90844BB2AAA16AADD54862C2FACF4BA71FCB8FF08695452DF3DD7CE86A8F6C8AAE4901BF440CCACE4589A353BB972C3F220C34B290CD0B69D36AC77B2070F82918C43BF4B951629643A0C84D390433BF59F5CBE8B486A78969A5CEF04B7FD9431F9D71BD7AD0D9BC98351D250CA451EAA39C37597A1C0B8D28ADE05727807D904987D5C3020B5E9991CF966B9E16F25ED4E361E5091EB81967AF3392B247FA515B835D12717602FD3E273CF7567DBABE773D9608DF50E0A1626C9ADFCEE43CF6D065BC88C77EDDE708AE206ACF5A7CA578AE149AFC536200426E2D9FA9B1D29C0C2D148E3F92A6692106431B521B0748A9D5F644A04D020111",
	"30820120300D06092A864886F70D01010105000382010D00308201080282010100A7BB1A552F0AC99B23E29841DA6A2F997B592E41EDF591CDA7AB3D8800403E69D37580B2C28204F1E8DB2842631C0BCD8BA50A40373AD7AAFED143C5C3A63FA1006399F958B89E78FFEDC56E8871C3A9186FFCE96B163C56AFB0328FF86F33BDB72604E3BD86E55C8F0C5006BDC04FBCEA69243E83ED33CE222BF9ECE217753EDFA4C9FC23995D4115DE3A82F6E170860F59F11DE9281BE85FFF6B556C0F33353C65ADFC1B830185242BC0783972A5B12D1A246B3AA1A543D7F0975A51EB3FC2AC600F1FBCBB157DF6FEFB1C42A55383F0AE18BD45DFFC5D49348732724FA10E749236EB20A8C8A75278A2AC4999243C8ED6A0377B5D771CDBF036811D3C63B7020111",
	"30820120300D06092A864886F70D01010105000382010D00308201080282010100ABAF06E6F1C7CBBFACE3535260588573CC90476137D3F29DC7239982FF475B03FA61EA0BD2EC3C91CD6F799E97940098BD08D098668DC3F2A8CBE386BCDD622FB6F3D607A86F5DE89E6C7C4A20DDCD5B32B4F7B5F960670B5217E3BBDC1D81845A9025C41D919F4F2D8EB5A4BFF1FA3A8A4332893E986FFDC105024E3AC9AC52509485F6B8226DD407AC04A2EFB9DAC44DD90E61A0CB8E11A9E5B604577FC8BDD44A74C23F594D8F820DCA8B2B61129DDF6D452D85E01D122D61CE1EF333B3D450901EBC7924BEB6E6A3706BE34625CEDCE93EABFECA15E4FDB459BACD0F31B3B31576E4C551FE9BA4CBAC44BD91608E429AE13E4A915E472F0A26688E653F2B020111",
	"30820120300D06092A864886F70D01010105000382010D00308201080282010100C801619F66A756124DB81D8F27EF75C8BC7A59F6F6141265B32912CA395188D428CB6BE430F920A2CE63680A8D7D14740881377E65B441E6428BE88A7B1B9959C2A29375C4940B6E610015868724AEEEBAF8688A44A9DB0A8E99F4224681D76B3D2B272B9B49A8190C01083F2BD28B4A119D5A09C4F5FE28601250B2F2FF10C9B11FC2AFF9020399909ED512FF27CFA091FE0288960499E2637B790DD646C653B81E90EE4DC235A0B4B29304B6C802F04DF118AAC02B84D5C11E473B5BB9C13BE44D509862EAE18FECD84615F1CBD45898F8F440B2E584BD9385E8F4D826AE2A1B4B5019919F0E33CC06C243F83A51DA20E022157C701031AE3971EE7FA3131D020111",
	"30820120300D06092A864886F70D01010105000382010D00308201080282010100DE07DC9B2F70B9EE981480370C3997059E7D9D8DF84D27E397A5F61765A8C5EE8F5DE3D8A083828D1289273790B438C81431616B6F6AC1E6BAEC469E9948F18970E1D275C74D25C31E16B38D2F83541EF7B0D72DD3448CA8EDADB7E99FA6405C038585459ECEAAD6FDEC0BCE6A4BFB2A4128413480BC39D7AE0AF3FCF39581896CFB1476BA83E5291B891AEA7B1D7BE9E543404BDC6C233646C2769E7C4B5DF1E678340BFA632F5C1230BD3E16FD2A73E96AB74598A09D962630A8A9A3928F067A4B2994EF7903C84A671A5B02925C1BA1D1030EEFE06D2342F967EA9A072E5B245C55BDEC2BDE238F3FC2213CF06611DBCA2558B2D6514C104A1E81254CA2DB020111",
	"30820120300D06092A864886F70D01010105000382010D00308201080282010100CB1AA45A9A73670DE75B0EEEBC0C15F78CAC03377A4AD2CAA393A8565E12209E799CDB4511DDA5145D2FFCE98A0506103AA77426F5AC6C9AA6F8A892D6D48B24525BECFBB9CC924E370899D91B17B62E8A50E07D4ED9136747B173B09E9B6B7C1346554CB674EE3E0F81A975ECE2F579B56E2B8F02F1108B3B7D7D6A6D803BB4810EDC010431A509631F209B75F143D22E774E2D5CE914B58CB085C2624751B65B76A10684BC6B5459473D5CBB22B17B6014E2639B213C96E5D330B199E25843FA40945BBA976763B8BE629AFEB131C549AF3FA474164BDBDE7A6D9B28BD9D433083B4418D245538019B4AACBB070406030D97173A7DD943AFA482332FDC189F020111",
	"30820120300D06092A864886F70D01010105000382010D00308201080282010100B4F7AEBFDD39C85C3D2D626D42C2034ED801E4C9EB867C2E4E432B4D8AB9C44BF852A8070477EE71927034B72564C04C8CFEEA21522E6C4728384438BCED3AD8424AEAC49A12199B52F0595A57521155F668D93131BCC071CBC1A3E3D546A718621608E038F16CFC24F581B043950E0304887EF05C3E8FE090A8D52CD63E1EBDADDF46C80E5FD101E06163FF7A2CD7481479503746CD50E4F3752BADFFF2FD84B9B07B03E95A2EDD2363ECB9A97CC652171A2245D7CA7ED12767413CD66A186FD3ED41CB78254F1554EEC2B7158F1EBE400BBDA1EA9B4AC1A5B98442341115588444BAF6149A43D38AAE0FF9B2B2D83532BEAE3A44B51BC20FC7BBD4B3EE101B020111",
	"30820120300D06092A864886F70D01010105000382010D00308201080282010100B25415E401B0490220ECC68617FB17474E3598BAAE6F94632D7081A20401AB1C4082DBDF9A889892415F1987AF8C381231BFBEFFBE6E0F9649CB492B365D33A623C3E20D5BDC964DB9851D968D661786F785BEF39BDBA9A710305958065370F0B805FD26328E6FF0C78B007CB2D92020D82E6980CDBE8C0A69C432906106BA193FBDAD281E3CA6BD3BA69EE31523DF811CC861BD52041EFCC2AF25E8451CFEC78C2BA6A0FB2E3F738D60EC4853B38646838468CE91A8EEDF3A2FBF0FD561DEE15AF9EFC1520A2EE975F828CD038F85BD01ABB30C7C4024C8457C21B39A42876AE3CCFC5ABAA8CA8CDAFBAE1643A7422DA11CF37AA04F0718CC2002640A7AD1A1020111"
};



class	ICryptFactory_DHKeyAndDES	: public	ICryptFactory
{
private:
	class	IKeyExchanger_X		: public	ICryptFactory::IKeyExchanger
	{
	protected:
		enum
		{
			MAX_KEY_SIZE	= 2048/8,
		};
		RandomPool			&m_RP;
		DH					*m_pDH;
		int					m_nKeyLen;
		unsigned char		m_Private[MAX_KEY_SIZE]; 
		unsigned char		m_Public[MAX_KEY_SIZE]; 
		unsigned char		m_AgreedValue[MAX_KEY_SIZE]; 
		ICryptFactory_DHKeyAndDES	*m_pHost;
	public:
		IKeyExchanger_X(ICryptFactory_DHKeyAndDES *pHost, int nType, RandomPool &RP)
		: m_RP(RP)
		, m_pHost(pHost)
		{
			nType	%= m_pHost->m_nDHSTRNUM;
			const char	*pDHSTR	= m_pHost->m_pDHSTR[nType];
			std::istringstream	ss(pDHSTR);
			//FileSource		f(ss, true, new Base64Decoder());
			FileSource		f(ss, true, new HexDecoder());
			m_pDH			= new DH(f);
			m_nKeyLen		= (int)m_pDH->AgreedValueLength();
			assert(m_nKeyLen<=MAX_KEY_SIZE);
		}
		~IKeyExchanger_X()
		{
			delete	m_pDH;
		}
		virtual	void	SelfDestroy()
		{
			delete	this;
		}
		virtual	int		MakeOwnData()
		{
			m_pDH->GenerateKeyPair(m_RP, m_Private, m_Public);
			return	0;
		}
		virtual	int		GetPubSize() const
		{
			return	m_nKeyLen;
		}
		virtual	const void *	GetPubData()
		{
			return	m_Public;
		}
		virtual	int		_Agree(const void *pPubData, int nPubSize)
		{
			if( nPubSize != m_nKeyLen )
			{
				return	-1;
			}
			if( !m_pDH->Agree(m_AgreedValue, m_Private, (const byte *)pPubData) )
			{
				return	-2;
			}
			return	0;
		}
		virtual	int		Agree1(const void *pPubData, int nPubSize)
		{
			return	_Agree(pPubData, nPubSize);
		}
		virtual	int		Agree2(const void *pPubData, int nPubSize)
		{
			return	_Agree(pPubData, nPubSize);
		}
		virtual	int		AppendCryptInfo(const void *pInfo, size_t nSize)
		{
			// 如果pInfo过长那么后面的就不用了
			int	mi	= 0;
			unsigned char	*pMask	= (unsigned char *)pInfo;
			for(int i=0;i<m_nKeyLen;i++)
			{
				m_AgreedValue[i]	^= pMask[mi];
				mi	++;
				if( mi>=(int)nSize )
				{
					mi	= 0;
				}
			}
			return	0;
		}
		virtual	const void *	GetKey()
		{
			return	m_AgreedValue;
		}
		virtual	int		GetKeySize()
		{
			return	m_nKeyLen;
		}
	};
	
//////////////////////////////////////////////////////////////////////////
	
	class	IKeyExchanger_RSA		: public	ICryptFactory::IKeyExchanger
	{
	protected:
		
		enum
		{
			MAX_KEY_SIZE		= 2048/8,
			MAX_PUBKEY_SIZE		= 4096,
			MAX_PRIKEY_SIZE		= 2048,
		};
		
		RandomPool					& m_RP;
	
		// 私钥和私钥长度
		char						m_szPriKey[MAX_PRIKEY_SIZE];
		unsigned int				m_nPriKeyLen;

		// 公钥和公钥长度
		char						m_szPubKey[MAX_PUBKEY_SIZE];
		unsigned int				m_nPubKeyLen;

		// 公钥和私钥对象
		RSAES_OAEP_SHA_Decryptor	* m_pPriKeyObj;
		RSAES_OAEP_SHA_Encryptor	* m_pPubKeyObj;

		char						m_AgreedValue[MAX_KEY_SIZE]; 
		unsigned int				m_nAgreeValueLen;
	
	private:
		

		ICryptFactory_DHKeyAndDES	*m_pHost;

	public:
		IKeyExchanger_RSA( ICryptFactory_DHKeyAndDES *pHost, int nType, RandomPool &RP )
			: m_RP(RP)
			, m_pHost(pHost)
		{
			const	int	cNums = 6;
			const	int cBitNum[cNums] = { 200, 192, 184, 176, 168, 160  };

			m_pPubKeyObj = NULL;
			m_pPriKeyObj = NULL;

			nType %= cNums;
			m_nAgreeValueLen = cBitNum[nType];
		}
		
		~IKeyExchanger_RSA()
		{
			if ( m_pPriKeyObj ) {
				delete	m_pPriKeyObj;
				m_pPriKeyObj = NULL;
			}
			
			if ( m_pPubKeyObj ) {
				delete	m_pPubKeyObj;
				m_pPubKeyObj = NULL;
			}
			
		}
		
		virtual	void	SelfDestroy()
		{
			delete	this;
		}
		
		virtual	int		MakeOwnData()
		{
			if ( m_pPriKeyObj ) {
				delete	m_pPriKeyObj;
				m_pPriKeyObj	= NULL;
			}

			if ( m_pPubKeyObj ) {
				delete	m_pPubKeyObj;
				m_pPubKeyObj	= NULL;
			}

			int		index = rand() % (m_pHost->m_RSADate.uKeyNum);

			ArraySink		asPri( (byte *)m_szPriKey, m_pHost->m_RSADate.uPriKeyLen );
			ArraySink		asPub( (byte *)m_szPubKey, m_pHost->m_RSADate.uPubKeyLen );		
			//
			std::istringstream	is1((m_pHost->m_RSADate.sPriKey)[index]); 
			FileSource priFile( /*static_cast<std::istream &>*/ is1, true, new HexDecoder );
			m_pPriKeyObj = new RSAES_OAEP_SHA_Decryptor( priFile );
			
			m_pPriKeyObj->DEREncode( asPri );
			m_nPriKeyLen	= (unsigned int)asPri.TotalPutLength() ;
			assert( m_nPriKeyLen <= MAX_PRIKEY_SIZE );

			
			std::istringstream	is2 ((m_pHost->m_RSADate.sPubKey)[index] );
			// 生成公钥并且把公钥的数据和长度存到成员里。			
			FileSource pubFile( is2, true, new HexDecoder );
			m_pPubKeyObj = new RSAES_OAEP_SHA_Encryptor ( pubFile );
			
			m_pPubKeyObj->DEREncode( asPub );
			m_nPubKeyLen	= (unsigned int)asPub.TotalPutLength() ;
			assert( m_nPubKeyLen <= MAX_PUBKEY_SIZE );
	
			return	0;
		}
		
		virtual	int		GetPubSize() const
		{
			return			m_nPubKeyLen;  
		}
		
		virtual	const void *	GetPubData()
		{
			return			m_szPubKey;	
		}

		// 在RSA算法中，这个函数没有实际作用
		virtual	int		_Agree(const void *pPubData, int nPubSize)
		{
			return	0;
		}
		
		// 服务端运行。
		virtual	int		Agree1(const void *pPubData, int nPubSize)
		{
			// 使用随即数生成对等密钥，并且使用客户端的公钥加密。
			wh_randhex( m_AgreedValue, m_nAgreeValueLen );
			assert( m_nAgreeValueLen <= MAX_KEY_SIZE );
			m_AgreedValue[m_nAgreeValueLen]=0;
					
			// 保存加密后的密钥的长度。
			try {
				_ServerMakeAgreeValue( (byte *)pPubData, nPubSize, m_AgreedValue, m_nAgreeValueLen, m_nPubKeyLen );
			}
			catch(...) {
				return -1;
			}


			return	0;
		}
		
		// 客户端运行
		virtual	int		Agree2(const void * pPubData, int nPubSize)
		{
			// 存放密钥长度
			try {
				_GetAgreeValueFromServer( (char *)pPubData, nPubSize );
			}
			catch(...) {
				return	-1;
			}
			return	0;
		}
		
		virtual	int		AppendCryptInfo(const void *pInfo, size_t nSize)
		{
			// 如果pInfo过长那么后面的就不用了
			int	mi	= 0;
			unsigned char	*pMask	= (unsigned char *)pInfo;
			for( unsigned int i=0;i<m_nAgreeValueLen;i++ )
			{
				m_AgreedValue[i]	^= pMask[mi];
				mi	++;
				if( mi>=(int)nSize )
				{
					mi	= 0;
				}
			}
			return	0;
		}
		
		virtual	const void *	GetKey()
		{
			return		m_AgreedValue;
		}
		
		virtual	int		GetKeySize()
		{
			return		m_nAgreeValueLen;
		}

	private:
		// 服务端调用，用来将对等key使用RSA加密。
		char *    _ServerMakeAgreeValue( const byte * pPubData, unsigned int nPubDateSize,  const char * sMsg, unsigned int nMsgLen, unsigned int & nRetLen )
		{
			if ( m_pPubKeyObj ) {
				delete	m_pPubKeyObj;
				m_pPubKeyObj = NULL;
			}

			StringSource		ss( pPubData, nPubDateSize, true );
			m_pPubKeyObj = new RSAES_OAEP_SHA_Encryptor( ss );

			std::string				str, ss1(sMsg, nMsgLen);	// 2007-5-16 如果直接吧std::string(sMsg, nMsgLen)写成StringSource的第一个参数，在slackware下的gcc3.3.4下会报错“error: parse error before `;' token”
			StringSource( ss1, true, new PK_EncryptorFilter( m_RP, *m_pPubKeyObj,  new StringSink( str )));
		
			nRetLen = str.length();
			assert( nRetLen <= MAX_PUBKEY_SIZE );
			memcpy( m_szPubKey, str.c_str(), nRetLen );
			m_szPubKey[nRetLen] = 0; 
			return m_szPubKey;
		}
		
		// 客户端调用用于解密服务端加密的对等Key
		char *   _GetAgreeValueFromServer( const char * msg, int nMsgSize )
		{
			std::string	 str, ss1(msg, nMsgSize);
			StringSource( ss1, true, new PK_DecryptorFilter( m_RP, *m_pPriKeyObj, new StringSink(str)));
			
			m_nAgreeValueLen = str.length();
			assert( m_nAgreeValueLen <= MAX_KEY_SIZE );
			memcpy( m_AgreedValue, str.c_str(), m_nAgreeValueLen );
			m_AgreedValue[m_nAgreeValueLen] = 0;
			
			return	m_AgreedValue;
		}

	};

//////////////////////////////////////////////////////////////////////////
	
	
	class	ICryptor_X	: public	ICryptFactory::ICryptor
	{
	private:
		WHMessageStreamDES	m_des;
	public:
		ICryptor_X(int nType)
		: m_des(nType)
		{
		}
		virtual	void	SelfDestroy()
		{
			delete	this;
		}
		virtual	int		SetEncryptKey(const void *pKey, int nKeyLen)
		{
			Reset();
			return		m_des.SetEncryptKey((unsigned char *)pKey, nKeyLen);
		}
		virtual	int		SetDecryptKey(const void *pKey, int nKeyLen)
		{
			Reset();
			return		m_des.SetDecryptKey((unsigned char *)pKey, nKeyLen);
		}
		virtual	void	Reset()
		{
			m_des.Reset();
		}
		virtual	int		Encrypt(const void *pSrc, int nSize, void *pDst)
		{
			return		m_des.Encrypt((const unsigned char *)pSrc, nSize, (unsigned char *)pDst)?0:-1;
		}
		virtual	int		Decrypt(const void *pSrc, int nSize, void *pDst)
		{
			return		m_des.Decrypt((const unsigned char *)pSrc, nSize, (unsigned char *)pDst)?0:-1;
		}
	};
private:
	friend class		ICryptFactory_DHKeyAndDES::IKeyExchanger_X;	// 'friend' cannot be used during type definition
	RandomPool			m_RP;
	const char			**m_pDHSTR;
	int					m_nDHSTRNUM;

//////////////////////////////////////////////////////////////////////////
private:
	// RSA 数据
	//////////////////////////////////////////////////////////////////////////
	struct		RSAData 
	{
		const	char			** sPriKey;
		const	char			** sPubKey;
		unsigned	int		uKeyNum;
		unsigned	int		uPriKeyLen;
		unsigned	int		uPubKeyLen;


		RSAData()
		{
			sPriKey		= NULL;
			sPubKey		= NULL;
			uPriKeyLen	= 0;	
			uPubKeyLen	= 0;
			uKeyNum		= 0;
		}

		// RSA密钥的对数，私钥的字符串指针数组的指针，公钥的字符串指针数组的指针，私钥的长度(bit)，公钥的长度(bit)
		RSAData( unsigned int keyNum, const char ** priKey, const char ** pubKey, unsigned int priKeyLen, unsigned int pubKeyLen )
		{
			sPriKey		= priKey;
			sPubKey		= pubKey;
			uPriKeyLen	= priKeyLen;	
			uPubKeyLen	= pubKeyLen;
			uKeyNum		= keyNum;
		}
	};
	//////////////////////////////////////////////////////////////////////////

	RSAData				m_RSADate;
//////////////////////////////////////////////////////////////////////////
	
public:
	ICryptFactory_DHKeyAndDES()
	{
		m_pDHSTR		= g_pDHSTR;
		m_nDHSTRNUM		= CNDHSTRNUM;

		m_RSADate.sPriKey = cRSAPriKey;
		m_RSADate.sPubKey = cRSAPubKey;
		m_RSADate.uKeyNum = cRSAKeyNum;
		m_RSADate.uPriKeyLen = cRSAPriKeyLen;
		m_RSADate.uPubKeyLen = cRSAPubKeyLen;

	}
	~ICryptFactory_DHKeyAndDES()
	{
	}
	virtual int			SetParam(int nKey, void *pParam, int nSize)
	{
		switch( nKey )
		{
		case	1:		// DH 
			{
				// pParam必须指向一个在整个程序生存周期内都存在的指针数组
				// nSize就临时用来表示数组中元素的个数
				m_pDHSTR	= (const char **)pParam;
				m_nDHSTRNUM	= nSize;
			}
			break;
		
		case	2:		// RSA
			{
				RSAData	* p = (RSAData *)pParam;
				m_RSADate.sPriKey		= p->sPriKey;
				m_RSADate.sPubKey		= p->sPubKey;
				m_RSADate.uPriKeyLen	= p->uPriKeyLen;
				m_RSADate.uPubKeyLen	= p->uPubKeyLen;
				m_RSADate.uKeyNum		= p->uKeyNum;
			}	
			break;
		default:
			break;
		}
		return	0;
	}
	// 随机数初始化，默认参数表示利用时间作初始化种子
	virtual void		RandInit(const char *cszSeed, int nLen)
	{
		if( cszSeed )
		{
			m_RP.Put((const byte *)cszSeed, nLen);
		}
		else
		{
			char	szSeed[64];
			sprintf(szSeed, "%ld%d", wh_time(), wh_gettickcount());
			m_RP.Put((const byte *)szSeed, strlen(szSeed));
		}
	}
	// 自己销毁自己
	virtual	void		SelfDestroy()
	{
		delete			this;
	}
	// 创建一个加密器
	virtual	IKeyExchanger *	CreateIKeyExchanger(int nType)
	{
		if ( (nType%2)==0 ) {
			return	new IKeyExchanger_X(this, nType/2, m_RP);
		}
		else {
			return	new IKeyExchanger_RSA(this, nType/2, m_RP) ;
		}
	}
	// 创建一个加密器
	virtual	ICryptor *	CreateICryptor(int nType)
	{
		enum
		{
			NUM	= 5,
		};
		static const	int	CNT[NUM]	= {1,3,5,7,11};
		nType	%= NUM;
		return	new ICryptor_X(CNT[nType]);
	}
};

// 快速加密方式
class	ICryptFactory_DHKeyAndQuickCrypt	: public	ICryptFactory_DHKeyAndDES
{
public:
	class	ICryptor_X	: public	ICryptFactory::ICryptor
	{
	private:
		WHMessageStreamQuickCrypt	m_qc;
	public:
		ICryptor_X(int nType)
		{
		}
		virtual	void	SelfDestroy()
		{
			delete	this;
		}
		virtual	int		SetEncryptKey(const void *pKey, int nKeyLen)
		{
			Reset();
			return		m_qc.SetEncryptKey((unsigned char *)pKey, nKeyLen);
		}
		virtual	int		SetDecryptKey(const void *pKey, int nKeyLen)
		{
			Reset();
			return		m_qc.SetDecryptKey((unsigned char *)pKey, nKeyLen);
		}
		virtual	void	Reset()
		{
			m_qc.Reset();
		}
		virtual	int		Encrypt(const void *pSrc, int nSize, void *pDst)
		{
			return		m_qc.Encrypt((const unsigned char *)pSrc, nSize, (unsigned char *)pDst)?0:-1;
		}
		virtual	int		Decrypt(const void *pSrc, int nSize, void *pDst)
		{
			return		m_qc.Decrypt((const unsigned char *)pSrc, nSize, (unsigned char *)pDst)?0:-1;
		}
	};
	// 创建一个加密器
	virtual	ICryptor *	CreateICryptor(int nType)
	{
		return	new ICryptor_X(0);
	}
};

ICryptFactory *	ICryptFactory_DHKeyAndDES_Create()
{
	return	new	ICryptFactory_DHKeyAndDES;
}
ICryptFactory *	ICryptFactory_DHKeyAndQuickCrypt_Create()
{
	return	new	ICryptFactory_DHKeyAndQuickCrypt;
}

class	CardCode_I_Base
{
protected:
	enum
	{
		RAND_LEN		= 3+2,								// 随机部分的长度
		CS_LEN			= 3,								// 校验核部分的长度
		RAWBUF_BITS		= CARDCODE_TYPE_LEN*8+24+16+30,		// 纯数据的bit数
		POS_CHECKSUM	= CARDCODE_TYPE_LEN+RAND_LEN,		// 写校验核的位置（后面2.5字节，实际就是计算4字节，然后重叠一部分）
		PASSLEN			= WHMD5LEN/2,
	};
	unsigned char		m_szPass[WHMD5LEN];
	#pragma pack(1)
	union	U_CODE_BUF_T
	{
		unsigned char	szRawBuf[CARDCODE_LEN+1];			// 没有变成32进制之前的生数据
		struct
		{
			char		szType[CARDCODE_TYPE_LEN];			// 类型串
			unsigned char	nCurNo[3];						// 递增序号
			unsigned short	nBatchNumber;					// 批号
			unsigned int	nCheckSum;						// 校验核（2.5*8 bit）

		};

		void	SetCurNo(unsigned int n)
		{
			memcpy(&nCurNo, &n, sizeof(nCurNo));
		}
		unsigned int	GetCurNo() const
		{
			unsigned int	n	= 0;
			memcpy(&n, nCurNo, sizeof(nCurNo));
			return	n;
		}
	}m_u;
	#pragma pack()
public:
	// 设置加密或解密密码
	int	SetPass(const char *cszPass)
	{
		whmd5(cszPass, strlen(cszPass), m_szPass);
		// 因为用不到那么长的密码
		for(int i=0;i<PASSLEN;i++)
		{
			m_szPass[i]	^= m_szPass[i+PASSLEN];
		}
		return	0;
	}
	// 校验核计算
	void	CheckSum_Calc()
	{
		m_u.nCheckSum	= crc32((char *)m_u.szRawBuf, POS_CHECKSUM);
		m_u.nCheckSum	^= (m_u.nCheckSum & 0xFFF00000) >> (8+4);
		m_u.nCheckSum	&= 0x000FFFFF;
	}
	// 校验核检测（只能检测一次，原来的会被覆盖）
	bool	CheckSum_Check()
	{
		unsigned int	nCheckSum			= m_u.nCheckSum;
		CheckSum_Calc();
		return	nCheckSum==m_u.nCheckSum;
	}
	// 数据加密（注意，因为最后一个字节其实只有0.5字节有效，所以不用加密）
	void	Encrypt()
	{
		WHDES_XOR_AC_EN(m_u.szRawBuf+CARDCODE_TYPE_LEN, RAND_LEN+CS_LEN-1, m_szPass, PASSLEN);
	}
	// 数据解密
	void	Decrypt()
	{
		WHDES_XOR_AC_DE(m_u.szRawBuf+CARDCODE_TYPE_LEN, RAND_LEN+CS_LEN-1, m_szPass, PASSLEN);
	}
	void	To32(char *pszBuf, int nBufLen)
	{
		// 把szRawBuf变成32进制数
		memcpy(pszBuf, m_u.szRawBuf, CARDCODE_TYPE_LEN);
		base32_line_encode(m_u.szRawBuf+CARDCODE_TYPE_LEN, RAND_LEN+CS_LEN, pszBuf+CARDCODE_TYPE_LEN, nBufLen-CARDCODE_TYPE_LEN);
		// 把最后一个表示0的base32字符取消
		pszBuf[CARDCODE_LEN]	= 0;
	}
	void	From32(const char *pszBuf)
	{
		// 把32进制数变成szRawBuf
		WHMEMSET0(m_u.szRawBuf);
		memcpy(m_u.szRawBuf, pszBuf, CARDCODE_TYPE_LEN);
		base32_line_decode(pszBuf+CARDCODE_TYPE_LEN, m_u.szRawBuf+CARDCODE_TYPE_LEN, CARDCODE_LEN);
	}
};
class	CardCodeGen_I	: public CardCodeGen, public CardCode_I_Base
{
private:
	unsigned short		m_nBatchNumber;
	unsigned int		m_nStartNo;
	unsigned int		m_nCurNo;	
public:
	CardCodeGen_I()
	{
		SetPass("tmxwwudi");
	}
	// 设置初始参数
	// cszType	两字节
	virtual int	SetParam(const char *cszType, unsigned short nBatchNumber, unsigned int nStartNo)
	{
		memcpy(m_u.szRawBuf, cszType, CARDCODE_TYPE_LEN);
		m_nStartNo		= nStartNo;
		m_nCurNo		= m_nStartNo;
		if( nBatchNumber>0 )
		{
			m_nBatchNumber		= nBatchNumber;
		}
		else
		{
			// 把今天距离2008-01-01的天数作为批号
			m_nBatchNumber		= ((unsigned int)(wh_time()-WHTIME_20080101)) / (24*3600);
		}
		return	0;
	}
	virtual int	SetPass(const char *cszPass)
	{
		return	CardCode_I_Base::SetPass(cszPass);
	}
	// 生成一条记录（必须保证pszBuf不得小于CARDCODE_LEN+1字节）
	virtual unsigned int	Gen(char *pszBuf, int nBufLen, int nNo)
	{
		if( nNo>0 )
		{
			m_nCurNo	= nNo;
		}
		else
		{
			if( m_nCurNo>=0xFFFFFF )								// 已经生成的太多了
			{
				return		-1;
			}
			// 增加序号
			m_nCurNo	++;
		}
		// 批号填入
		m_u.nBatchNumber	= m_nBatchNumber;
		// 序号填入缓冲
		m_u.SetCurNo(m_nCurNo);
		// 计算校验核（放到nCheckSum的位置）
		CheckSum_Calc();
		// 数据加密
		Encrypt();
		// 变成32进制
		To32(pszBuf, nBufLen);
		// 返回序号
		return	m_nCurNo;
	}
};
CardCodeGen *	CardCodeGen::Create()
{
	return	new CardCodeGen_I;
}

class	CardCodeCheck_I	: public CardCodeCheck, public CardCode_I_Base
{
private:
	unsigned short		m_nBatchNumber;
	unsigned int		m_nStartNo;
	unsigned int		m_nCurNo;
public:
	CardCodeCheck_I()
	{
		SetPass("tmxwwudi");
	}
	virtual int	SetPass(const char *cszPass)
	{
		return	CardCode_I_Base::SetPass(cszPass);
	}
	// 生成一条记录（必须保证pszBuf不得小于CARDCODE_LEN+1字节）
	virtual int	Check(const char *pszBuf, INFO_T *pInfo)
	{
		// 从32进制变回来
		From32(pszBuf);
		// 数据解密
		Decrypt();

		// 校验一下
		if( !CheckSum_Check() )
		{
			return	-1;
		}

		// 批号
		pInfo->nBatchNumber	= m_u.nBatchNumber;
		// 序号
		pInfo->nNo			= m_u.GetCurNo();
		// 类型
		memcpy(pInfo->szType, m_u.szType, sizeof(m_u.szType));
		pInfo->szType[sizeof(m_u.szType)]	= 0;

		return	0;
	}
};
CardCodeCheck *	CardCodeCheck::Create()
{
	return	new CardCodeCheck_I;
}

}		// EOF namespace n_whcmn
